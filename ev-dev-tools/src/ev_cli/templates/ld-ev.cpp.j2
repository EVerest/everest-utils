{% from "helper_macros.j2" import print_template_info, var_to_cpp, print_spdx_line %}
{{ print_spdx_line('Apache-2.0') }}
{{ print_template_info('2') }}

#include "{{ info.ld_ev_header }}"

#include "{{ info.module_header }}"
{% for impl in provides %}
#include "{{ impl.class_header }}"
{% endfor %}

#include <boost/dll/alias.hpp>
#include <utils/types.hpp>

namespace module {

// FIXME (aw): could this way of keeping static variables be changed somehow?
static Everest::ModuleAdapter adapter {};
static Everest::PtrContainer<{{info.class_name }}> mod_ptr {};

// per module configs
{# FIXME (aw): instead of being static, this could also be inside a map #}
{% for impl in provides %}
static {{ impl.id }}::Conf {{ impl.id }}_config;
{% endfor %}
static Conf module_conf;
static ModuleInfo module_info;

void LdEverest::init(ModuleConfigs module_configs, const ModuleInfo& mod_info) {
    EVLOG(debug) << "init() called on module {{ info.name }}";

    // populate config for provided implementations
    {% for impl in provides %}
    auto {{ impl.id }}_config_input = std::move(module_configs["{{ impl.id }}"]);
    {% for item in impl.config %}
    {{ impl.id }}_config.{{ item.name }} = boost::get<{{ item.cpp_type }}>({{ impl.id }}_config_input["{{ item.name }}"]);
    {% endfor %}

    {% endfor %}
    {% if info.module_config|length %}

    {% for item in info.module_config %}
    module_conf.{{ item.name }} = boost::get<{{ item.cpp_type }}>(module_configs["!module"]["{{ item.name }}"]);
    {% endfor %}
    {% endif %}

    module_info = mod_info;

    mod_ptr->init();
}

void LdEverest::ready() {
    EVLOG(debug) << "ready() called on module {{ info.name }}";
    mod_ptr->ready();
}

void register_call_handler(Everest::ModuleAdapter::CallFunc call) {
    EVLOG(debug) << "registering call_cmd callback for {{ info.name }}";
    adapter.call = std::move(call);
}

void register_publish_handler(Everest::ModuleAdapter::PublishFunc publish) {
    EVLOG(debug) << "registering publish_var callback for {{ info.name }}";
    adapter.publish = std::move(publish);
}

void register_subscribe_handler(Everest::ModuleAdapter::SubscribeFunc subscribe) {
    EVLOG(debug) << "registering subscribe_var callback for {{ info.name }}";
    adapter.subscribe = std::move(subscribe);
}

void register_ext_mqtt_publish_handler(Everest::ModuleAdapter::ExtMqttPublishFunc ext_mqtt_publish) {
    EVLOG(debug) << "registering external_mqtt_publish callback for {{ info.name }}";
    adapter.ext_mqtt_publish = std::move(ext_mqtt_publish);
}

void register_ext_mqtt_subscribe_handler(Everest::ModuleAdapter::ExtMqttSubscribeFunc ext_mqtt_subscribe) {
    EVLOG(debug) << "registering external_mqtt_handler callback for {{ info.name }}";
    adapter.ext_mqtt_subscribe = std::move(ext_mqtt_subscribe);
}

std::vector<Everest::cmd> everest_register(const json& connections) {
    EVLOG(debug) << "everest_register() called on module {{ info.name }}";

    adapter.check_complete();

    {% for impl in provides %}
    auto p_{{ impl.id }} = std::make_unique<{{ impl.id }}::{{ impl.class_name }}>(&adapter, mod_ptr, {{ impl.id }}_config);
    adapter.gather_cmds(*p_{{ impl.id }});

    {% endfor %}
    {% for requirement in requires %}
    {% if requirement.is_vector %}
    auto r_{{ requirement.id }} = std::vector<std::unique_ptr<{{ requirement.class_name }}>>();
    if (connections.contains("{{ requirement.id }}")) {
        for (int idx = 0; idx < connections["{{ requirement.id }}"].size(); idx++) {
            r_{{ requirement.id }}.emplace_back(std::make_unique<{{ requirement.class_name }}>(&adapter, Requirement{"{{ requirement.id }}", idx}));
        }
    }
    {% else %}
    auto r_{{ requirement.id }} = std::make_unique<{{ requirement.class_name }}>(&adapter, Requirement{"{{ requirement.id }}", 0});
    {% endif %}
    {% endfor %}

    {% if info.enable_external_mqtt %}
    static Everest::MqttProvider mqtt_provider(adapter);
    {% endif %}

    static {{ info.class_name }} module(
    module_info,
    {%- if info.enable_external_mqtt %}mqtt_provider, {% endif -%}
    {%- for impl in provides -%}
    std::move(p_{{ impl.id }}){{ ', ' }}
    {%- endfor -%}
    {%- for requirement in requires -%}
    std::move(r_{{ requirement.id }}){{ ', ' }}
    {%- endfor -%}
    module_conf);

    mod_ptr.set(&module);

    return adapter.registered_commands;
}

} // namespace module

// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast,performance-no-int-to-ptr,cppcoreguidelines-avoid-non-const-global-variables)
BOOST_DLL_ALIAS(module::LdEverest::init, init)
// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast,performance-no-int-to-ptr,cppcoreguidelines-avoid-non-const-global-variables)
BOOST_DLL_ALIAS(module::LdEverest::ready, ready)
// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast,performance-no-int-to-ptr,cppcoreguidelines-avoid-non-const-global-variables)
BOOST_DLL_ALIAS(module::everest_register, everest_register)
// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast,performance-no-int-to-ptr,cppcoreguidelines-avoid-non-const-global-variables)
BOOST_DLL_ALIAS(module::register_call_handler, everest_register_call_cmd_callback)
// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast,performance-no-int-to-ptr,cppcoreguidelines-avoid-non-const-global-variables)
BOOST_DLL_ALIAS(module::register_publish_handler, everest_register_publish_var_callback)
// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast,performance-no-int-to-ptr,cppcoreguidelines-avoid-non-const-global-variables)
BOOST_DLL_ALIAS(module::register_subscribe_handler, everest_register_subscribe_var_callback)
// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast,performance-no-int-to-ptr,cppcoreguidelines-avoid-non-const-global-variables)
BOOST_DLL_ALIAS(module::register_ext_mqtt_publish_handler, everest_register_external_mqtt_publish_callback)
// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast,performance-no-int-to-ptr,cppcoreguidelines-avoid-non-const-global-variables)
BOOST_DLL_ALIAS(module::register_ext_mqtt_subscribe_handler, everest_register_external_mqtt_handler_callback)
